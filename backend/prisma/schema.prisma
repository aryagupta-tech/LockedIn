generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── Enums ──────────────────────────────────────────────────────────────────────

enum UserRole {
  USER
  MODERATOR
  ADMIN
}

enum UserStatus {
  PENDING
  APPROVED
  REJECTED
  BANNED
}

enum ApplicationStatus {
  PENDING
  PROCESSING
  UNDER_REVIEW
  APPROVED
  REJECTED
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AppealStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  REJECTED
}

// ─── Models ─────────────────────────────────────────────────────────────────────

model User {
  id              String     @id @default(cuid())
  email           String     @unique
  username        String     @unique
  displayName     String
  passwordHash    String?
  avatarUrl       String?
  bio             String?

  githubId        Int?       @unique
  githubUsername   String?
  githubTokenEnc  String?

  codeforcesHandle String?
  leetcodeHandle   String?
  portfolioUrl     String?

  role            UserRole   @default(USER)
  status          UserStatus @default(PENDING)

  applications    Application[]
  refreshTokens   RefreshToken[]
  posts           Post[]
  comments        Comment[]
  postLikes       PostLike[]
  ownedCommunities Community[]              @relation("CommunityOwner")
  memberships     CommunityMember[]
  joinRequests    CommunityJoinRequest[]
  appeals         Appeal[]
  following       Follow[]                  @relation("Follower")
  followers       Follow[]                  @relation("Following")

  reviewedApps    Application[]             @relation("AppReviewer")
  reviewedJoins   CommunityJoinRequest[]    @relation("JoinReviewer")
  reviewedAppeals Appeal[]                  @relation("AppealReviewer")
  updatedWeights  ScoringWeight[]

  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([status])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  tokenHash String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model Application {
  id               String            @id @default(cuid())
  userId           String
  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  status           ApplicationStatus @default(PENDING)

  githubUrl        String?
  codeforcesHandle String?
  leetcodeHandle   String?
  portfolioUrl     String?

  score            Float?
  scoreBreakdown   Json?
  passingThreshold Float             @default(70)

  reviewerId       String?
  reviewer         User?             @relation("AppReviewer", fields: [reviewerId], references: [id])
  reviewNote       String?
  reviewedAt       DateTime?

  appeals          Appeal[]

  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  @@index([userId])
  @@index([status])
  @@map("applications")
}

model ScoringWeight {
  id          String   @id @default(cuid())
  key         String   @unique
  weight      Float
  description String?
  threshold   Float    @default(100)
  minimum     Float    @default(0)

  updatedById String?
  updatedBy   User?    @relation(fields: [updatedById], references: [id])
  updatedAt   DateTime @updatedAt

  @@map("scoring_weights")
}

model Post {
  id            String     @id @default(cuid())
  authorId      String
  author        User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  content       String
  codeSnippet   String?
  codeLanguage  String?
  communityId   String?
  community     Community? @relation(fields: [communityId], references: [id], onDelete: SetNull)
  likesCount    Int        @default(0)
  commentsCount Int        @default(0)

  comments      Comment[]
  likes         PostLike[]

  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  @@index([authorId])
  @@index([communityId])
  @@index([createdAt(sort: Desc)])
  @@map("posts")
}

model PostLike {
  id     String @id @default(cuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([postId, userId])
  @@map("post_likes")
}

model Comment {
  id       String    @id @default(cuid())
  postId   String
  post     Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  authorId String
  author   User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  content  String
  parentId String?
  parent   Comment?  @relation("Replies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[] @relation("Replies")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@map("comments")
}

model Community {
  id             String  @id @default(cuid())
  name           String
  slug           String  @unique
  description    String?
  ownerId        String
  owner          User    @relation("CommunityOwner", fields: [ownerId], references: [id])
  gatingCriteria Json?
  isPrivate      Boolean @default(true)
  memberCount    Int     @default(0)

  members      CommunityMember[]
  joinRequests CommunityJoinRequest[]
  posts        Post[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("communities")
}

model CommunityMember {
  id          String    @id @default(cuid())
  communityId String
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  role        String    @default("MEMBER")

  joinedAt    DateTime  @default(now())

  @@unique([communityId, userId])
  @@map("community_members")
}

model CommunityJoinRequest {
  id          String            @id @default(cuid())
  communityId String
  community   Community         @relation(fields: [communityId], references: [id], onDelete: Cascade)
  userId      String
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  status      JoinRequestStatus @default(PENDING)
  reviewerId  String?
  reviewer    User?             @relation("JoinReviewer", fields: [reviewerId], references: [id])
  reviewedAt  DateTime?

  createdAt   DateTime          @default(now())

  @@unique([communityId, userId])
  @@map("community_join_requests")
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  follower    User     @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String
  following   User     @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

model Appeal {
  id            String       @id @default(cuid())
  applicationId String
  application   Application  @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  userId        String
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  reason        String
  status        AppealStatus @default(PENDING)
  reviewerId    String?
  reviewer      User?        @relation("AppealReviewer", fields: [reviewerId], references: [id])
  reviewNote    String?
  reviewedAt    DateTime?

  createdAt     DateTime     @default(now())

  @@index([applicationId])
  @@index([status])
  @@map("appeals")
}
